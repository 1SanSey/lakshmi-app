/**
 * API маршруты для LakshmiApp
 * 
 * Этот файл содержит все REST API endpoints для работы с данными.
 * Все маршруты защищены аутентификацией через Replit OIDC.
 * 
 * Основные группы endpoints:
 * - /api/auth/* - аутентификация и управление пользователями
 * - /api/sponsors/* - управление спонсорами
 * - /api/receipts/* - управление поступлениями
 * - /api/costs/* - управление расходами
 * - /api/funds/* - управление фондами
 * - /api/fund-transfers/* - переводы между фондами
 * - /api/nomenclature/* - номенклатура расходов
 * - /api/expense-categories/* - категории расходов
 * - /api/reports/* - отчеты и аналитика
 */

import type { Express } from "express";
import { createServer, type Server } from "http";
import { newMemStorage as storage } from "./newMemStorage";
import { requireAuth } from "./simpleAuth";

// Схемы валидации для входящих данных
import { 
  insertSponsorSchema,          // Валидация данных спонсора
  insertReceiptSchema,          // Валидация данных поступления
  insertCostSchema,             // Валидация данных расхода
  insertCostItemSchema,         // Валидация элементов расхода
  insertFundSchema,             // Валидация данных фонда
  insertFundTransferSchema,     // Валидация перевода между фондами
  insertIncomeSourceSchema,     // Валидация источника дохода
  insertIncomeSourceFundDistributionSchema, // Валидация распределения по источникам
  insertReceiptItemSchema,      // Валидация элементов поступления
  insertManualFundDistributionSchema, // Валидация ручного распределения
  insertExpenseNomenclatureSchema,    // Валидация номенклатуры
  insertExpenseCategorySchema   // Валидация категории расходов
} from "@shared/schema";

import { z } from "zod"; // Библиотека для валидации схем

// Утилиты для обработки ошибок и валидации
import { handleValidationError, handleError, validateUserId, parseNumericParam, parseDateParam } from "./utils/validation";

// Утилиты для формирования HTTP ответов
import { notFound, unauthorized, badRequest, serverError, created, ok, noContent } from "./utils/responseHelpers";

/**
 * Регистрация всех API маршрутов в Express приложении
 * 
 * @param app - Express приложение
 * @returns HTTP сервер для работы с WebSocket и другими протоколами
 */
export async function registerRoutes(app: Express): Promise<Server> {
  // === МАРШРУТЫ АУТЕНТИФИКАЦИИ ===
  
  /**
   * Получение информации о текущем пользователе
   * GET /api/auth/user
   * 
   * Возвращает данные пользователя из сессии после аутентификации через Replit OIDC.
   * Используется для проверки статуса аутентификации и получения профиля пользователя.
   */
  app.get('/api/auth/user', (req: any, res) => {
    // Проверяем наличие пользователя в сессии
    if (req.session && (req.session as any).userId) {
      const userId = (req.session as any).userId;
      const user = storage.getUserById!(userId);
      
      if (user) {
        return ok(res, {
          id: user.id,
          username: user.username,
          firstName: user.firstName,
          lastName: user.lastName,
        });
      }
    }
    
    return unauthorized(res, "Необходимо войти в систему");
  });

  // === МАРШРУТЫ СПОНСОРОВ ===
  
  /**
   * Получение списка спонсоров с возможностью поиска
   * GET /api/sponsors?search=название
   * 
   * Возвращает всех спонсоров пользователя с опциональной фильтрацией по имени.
   * Используется на странице управления спонсорами.
   */
  app.get("/api/sponsors", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const search = req.query.search as string;
      const sponsors = await storage.getSponsors(userId, search);
      ok(res, sponsors);
    } catch (error) {
      handleError(error, res, "Failed to fetch sponsors");
    }
  });

  app.get("/api/sponsors/:id", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const sponsor = await storage.getSponsor(req.params.id, userId);
      if (!sponsor) {
        return notFound(res, "Sponsor not found");
      }
      ok(res, sponsor);
    } catch (error) {
      handleError(error, res, "Failed to fetch sponsor");
    }
  });

  app.post("/api/sponsors", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const validatedData = insertSponsorSchema.parse(req.body);
      const sponsor = await storage.createSponsor(validatedData, userId);
      created(res, sponsor);
    } catch (error) {
      if (handleValidationError(error, res)) return;
      handleError(error, res, "Failed to create sponsor");
    }
  });

  app.put("/api/sponsors/:id", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const validatedData = insertSponsorSchema.partial().parse(req.body);
      const sponsor = await storage.updateSponsor(req.params.id, validatedData, userId);
      if (!sponsor) {
        return notFound(res);
      }
      ok(res, sponsor);
    } catch (error) {
      if (handleValidationError(error, res)) return;
      handleError(error, res, "Failed to update sponsor");
    }
  });

  app.delete("/api/sponsors/:id", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const deleted = await storage.deleteSponsor(req.params.id, userId);
      if (!deleted) {
        return notFound(res);
      }
      noContent(res);
    } catch (error) {
      handleError(error, res, "Failed to delete sponsor");
    }
  });

  // Receipt routes
  app.get("/api/receipts", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const search = req.query.search as string;
      const fromDate = req.query.fromDate ? new Date(req.query.fromDate as string) : undefined;
      const toDate = req.query.toDate ? new Date(req.query.toDate as string) : undefined;
      const page = parseInt(req.query.page as string) || 1;
      const limit = parseInt(req.query.limit as string) || 20;
      
      const result = await storage.getReceiptsPaginated(userId, search, fromDate, toDate, page, limit);
      ok(res, result);
    } catch (error) {
      console.error("Error fetching receipts:", error);
      serverError(res);
    }
  });

  app.get("/api/receipts/:id", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const receipt = await storage.getReceipt(req.params.id, userId);
      if (!receipt) {
        return notFound(res);
      }
      ok(res, receipt);
    } catch (error) {
      console.error("Error fetching receipt:", error);
      serverError(res);
    }
  });

  app.post("/api/receipts", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const receiptData = {
        ...req.body,
        amount: parseFloat(req.body.amount) || 0,
        date: new Date(req.body.date),
      };
      
      const receipt = await storage.createReceipt(receiptData, userId);
      
      // Don't automatically distribute funds - let user manually distribute them
      
      created(res, receipt);
    } catch (error) {
      console.error("Error creating receipt:", error);
      serverError(res);
    }
  });

  app.put("/api/receipts/:id", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      
      // Преобразуем данные для обновления поступления
      const receiptData = {
        ...req.body,
        amount: req.body.amount ? parseFloat(req.body.amount).toString() : undefined,
        date: req.body.date ? new Date(req.body.date) : undefined,
      };
      
      const receipt = await storage.updateReceipt(req.params.id, receiptData, userId);
      if (!receipt) {
        return notFound(res);
      }
      
      // Note: Fund redistribution will be handled manually by user
      
      ok(res, receipt);
    } catch (error) {
      if (error instanceof z.ZodError) {
        console.error("Validation error:", error.errors);
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      console.error("Error updating receipt:", error);
      serverError(res);
    }
  });

  app.delete("/api/receipts/:id", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const deleted = await storage.deleteReceipt(req.params.id, userId);
      if (!deleted) {
        return notFound(res);
      }
      noContent(res);
    } catch (error) {
      console.error("Error deleting receipt:", error);
      serverError(res);
    }
  });

  app.post("/api/receipts/:receiptId/items", requireAuth, async (req: any, res) => {
    try {
      const { receiptId } = req.params;
      const { sponsorId, amount } = req.body;
      
      const receiptItem = await storage.createReceiptItem({
        receiptId,
        sponsorId,
        amount: parseFloat(amount).toString(),
      });
      
      created(res, receiptItem);
    } catch (error) {
      console.error("Error creating receipt item:", error);
      res.status(500).json({ error: "Failed to create receipt item" });
    }
  });

  app.delete("/api/receipts/:receiptId/items", requireAuth, async (req: any, res) => {
    try {
      const { receiptId } = req.params;
      await storage.deleteReceiptItems(receiptId);
      noContent(res);
    } catch (error) {
      console.error("Error deleting receipt items:", error);
      res.status(500).json({ error: "Failed to delete receipt items" });
    }
  });

  // Cost routes - новая структура
  app.get("/api/costs", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const search = req.query.search as string;
      const expenseCategoryId = req.query.expenseCategoryId as string;
      const fromDate = req.query.fromDate ? new Date(req.query.fromDate as string) : undefined;
      const toDate = req.query.toDate ? new Date(req.query.toDate as string) : undefined;
      const page = parseInt(req.query.page as string) || 1;
      const limit = parseInt(req.query.limit as string) || 20;
      
      // Always use pagination for consistency with other endpoints
      const result = await storage.getCostsPaginated(userId, search, expenseCategoryId, fromDate, toDate, page, limit);
      ok(res, result);
    } catch (error) {
      console.error("Error fetching costs:", error);
      serverError(res);
    }
  });

  app.get("/api/costs/:id", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const cost = await storage.getCost(req.params.id, userId);
      if (!cost) {
        return notFound(res);
      }
      ok(res, cost);
    } catch (error) {
      console.error("Error fetching cost:", error);
      serverError(res);
    }
  });

  app.post("/api/costs", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      
      // Преобразуем данные вручную
      const requestData = {
        ...req.body,
        date: new Date(req.body.date),
        totalAmount: String(req.body.totalAmount)  // Принудительно конвертируем в строку
      };
      
      console.log("Request data:", requestData);
      const validatedData = insertCostSchema.parse(requestData);
      console.log("Validated data:", validatedData);
      const cost = await storage.createCost(validatedData, userId);
      created(res, cost);
    } catch (error) {
      if (error instanceof z.ZodError) {
        console.error("Validation error:", error.errors);
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      console.error("Error creating cost:", error);
      res.status(500).json({ message: "Failed to create cost", error: (error as Error).message });
    }
  });

  app.put("/api/costs/:id", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const validatedData = insertCostSchema.partial().parse(req.body);
      const cost = await storage.updateCost(req.params.id, validatedData, userId);
      if (!cost) {
        return notFound(res);
      }
      ok(res, cost);
    } catch (error) {
      if (handleValidationError(error, res)) return;
      handleError(error, res, "Failed to update cost");
    }
  });

  app.delete("/api/costs/:id", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const deleted = await storage.deleteCost(req.params.id, userId);
      if (!deleted) {
        return notFound(res);
      }
      noContent(res);
    } catch (error) {
      handleError(error, res, "Failed to delete cost");
    }
  });

  // Cost Items routes  
  app.get("/api/costs/:costId/items", requireAuth, async (req: any, res) => {
    try {
      const { costId } = req.params;
      const items = await storage.getCostItems(costId);
      ok(res, items);
    } catch (error) {
      console.error("Error fetching cost items:", error);
      serverError(res);
    }
  });

  app.post("/api/costs/:costId/items", requireAuth, async (req: any, res) => {
    try {
      const { costId } = req.params;
      const validatedData = insertCostItemSchema.parse(req.body);
      const costItem = await storage.createCostItem(validatedData, costId);
      created(res, costItem);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      console.error("Error creating cost item:", error);
      serverError(res);
    }
  });

  app.put("/api/cost-items/:id", requireAuth, async (req: any, res) => {
    try {
      const validatedData = insertCostItemSchema.partial().parse(req.body);
      const costItem = await storage.updateCostItem(req.params.id, validatedData);
      if (!costItem) {
        return notFound(res);
      }
      ok(res, costItem);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      console.error("Error updating cost item:", error);
      serverError(res);
    }
  });

  app.delete("/api/cost-items/:id", requireAuth, async (req: any, res) => {
    try {
      const deleted = await storage.deleteCostItem(req.params.id);
      if (!deleted) {
        return notFound(res);
      }
      noContent(res);
    } catch (error) {
      console.error("Error deleting cost item:", error);
      serverError(res);
    }
  });

  // Fund routes
  app.get("/api/funds", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const funds = await storage.getFunds(userId);
      ok(res, funds);
    } catch (error) {
      console.error("Error fetching funds:", error);
      serverError(res);
    }
  });

  app.get("/api/funds/:id", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const fund = await storage.getFund(req.params.id, userId);
      if (!fund) {
        return notFound(res);
      }
      ok(res, fund);
    } catch (error) {
      console.error("Error fetching fund:", error);
      serverError(res);
    }
  });

  app.post("/api/funds", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const validatedData = insertFundSchema.parse(req.body);
      const fund = await storage.createFund(validatedData, userId);
      created(res, fund);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      console.error("Error creating fund:", error);
      serverError(res);
    }
  });

  app.put("/api/funds/:id", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const validatedData = insertFundSchema.partial().parse(req.body);
      const fund = await storage.updateFund(req.params.id, validatedData, userId);
      if (!fund) {
        return notFound(res);
      }
      ok(res, fund);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      console.error("Error updating fund:", error);
      serverError(res);
    }
  });

  app.delete("/api/funds/:id", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const deleted = await storage.deleteFund(req.params.id, userId);
      if (!deleted) {
        return notFound(res);
      }
      noContent(res);
    } catch (error) {
      console.error("Error deleting fund:", error);
      serverError(res);
    }
  });

  app.get("/api/funds/balances", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const fundsWithBalances = await storage.getFundsWithBalances(userId);
      ok(res, fundsWithBalances);
    } catch (error) {
      console.error("Error fetching funds with balances:", error);
      serverError(res);
    }
  });

  // Fund distribution routes
  app.get("/api/receipts/:receiptId/distributions", requireAuth, async (req: any, res) => {
    try {
      const distributions = await storage.getFundDistributionsByReceipt(req.params.receiptId);
      ok(res, distributions);
    } catch (error) {
      console.error("Error fetching fund distributions:", error);
      serverError(res);
    }
  });

  // Dashboard statistics routes
  app.get("/api/dashboard/stats", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const stats = await storage.getDashboardStats(userId);
      ok(res, stats);
    } catch (error) {
      console.error("Error fetching dashboard stats:", error);
      serverError(res);
    }
  });

  app.get("/api/dashboard/activity", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const limit = req.query.limit ? parseInt(req.query.limit as string) : 5;
      const activity = await storage.getRecentActivity(userId, limit);
      ok(res, activity);
    } catch (error) {
      console.error("Error fetching recent activity:", error);
      serverError(res);
    }
  });

  // Income source routes
  app.get("/api/income-sources", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const incomeSources = await storage.getIncomeSources(userId);
      ok(res, incomeSources);
    } catch (error) {
      console.error("Error fetching income sources:", error);
      serverError(res);
    }
  });

  app.get("/api/income-sources/:id", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const incomeSource = await storage.getIncomeSource(req.params.id, userId);
      if (!incomeSource) {
        return notFound(res);
      }
      ok(res, incomeSource);
    } catch (error) {
      console.error("Error fetching income source:", error);
      serverError(res);
    }
  });

  app.post("/api/income-sources", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const validatedData = insertIncomeSourceSchema.parse(req.body);
      const incomeSource = await storage.createIncomeSource(validatedData, userId);
      created(res, incomeSource);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      console.error("Error creating income source:", error);
      serverError(res);
    }
  });

  app.put("/api/income-sources/:id", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const validatedData = insertIncomeSourceSchema.partial().parse(req.body);
      const incomeSource = await storage.updateIncomeSource(req.params.id, validatedData, userId);
      if (!incomeSource) {
        return notFound(res);
      }
      ok(res, incomeSource);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      console.error("Error updating income source:", error);
      serverError(res);
    }
  });

  app.delete("/api/income-sources/:id", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const deleted = await storage.deleteIncomeSource(req.params.id, userId);
      if (!deleted) {
        return notFound(res);
      }
      noContent(res);
    } catch (error) {
      console.error("Error deleting income source:", error);
      serverError(res);
    }
  });

  // Income source fund distribution routes
  app.get("/api/income-sources/:id/fund-distributions", requireAuth, async (req: any, res) => {
    try {
      const distributions = await storage.getIncomeSourceFundDistributions(req.params.id);
      ok(res, distributions);
    } catch (error) {
      console.error("Error fetching income source fund distributions:", error);
      serverError(res);
    }
  });

  app.post("/api/income-sources/:id/fund-distributions", requireAuth, async (req: any, res) => {
    try {
      const validatedData = insertIncomeSourceFundDistributionSchema.parse({
        ...req.body,
        incomeSourceId: req.params.id
      });
      const distribution = await storage.createIncomeSourceFundDistribution(validatedData);
      created(res, distribution);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      console.error("Error creating fund distribution:", error);
      serverError(res);
    }
  });

  app.delete("/api/income-sources/:id/fund-distributions", requireAuth, async (req: any, res) => {
    try {
      await storage.deleteIncomeSourceFundDistributions(req.params.id);
      noContent(res);
    } catch (error) {
      console.error("Error deleting fund distributions:", error);
      serverError(res);
    }
  });

  // Receipt items routes
  app.get("/api/receipts/:id/items", requireAuth, async (req: any, res) => {
    try {
      const receiptItems = await storage.getReceiptItems(req.params.id);
      ok(res, receiptItems);
    } catch (error) {
      console.error("Error fetching receipt items:", error);
      serverError(res);
    }
  });

  app.post("/api/receipts/:id/items", requireAuth, async (req: any, res) => {
    try {
      const validatedData = insertReceiptItemSchema.parse({
        ...req.body,
        receiptId: req.params.id
      });
      const receiptItem = await storage.createReceiptItem(validatedData);
      created(res, receiptItem);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      console.error("Error creating receipt item:", error);
      serverError(res);
    }
  });

  // Fund transfer routes
  app.get("/api/fund-transfers", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const transfers = await storage.getFundTransfers(userId);
      ok(res, transfers);
    } catch (error) {
      console.error("Error fetching fund transfers:", error);
      serverError(res);
    }
  });

  app.post("/api/fund-transfers", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const transferData = {
        ...req.body,
        amount: parseFloat(req.body.amount),
        userId
      };
      const transfer = await storage.createFundTransfer(transferData);
      created(res, transfer);
    } catch (error) {
      console.error("Error creating fund transfer:", error);
      serverError(res);
    }
  });

  app.delete("/api/fund-transfers/:id", requireAuth, async (req: any, res) => {
    try {
      const deleted = await storage.deleteFundTransfer(req.params.id);
      if (!deleted) {
        return notFound(res);
      }
      noContent(res);
    } catch (error) {
      console.error("Error deleting fund transfer:", error);
      serverError(res);
    }
  });

  // Manual fund distribution routes
  app.get("/api/manual-fund-distributions", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const distributions = await storage.getManualFundDistributions(userId);
      ok(res, distributions);
    } catch (error) {
      console.error("Error fetching manual fund distributions:", error);
      res.status(500).json({ error: "Ошибка при получении ручных распределений" });
    }
  });

  app.post("/api/manual-fund-distributions", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const validatedData = insertManualFundDistributionSchema.parse(req.body);
      const distribution = await storage.createManualFundDistribution(validatedData, userId);
      created(res, distribution);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      console.error("Error creating manual fund distribution:", error);
      res.status(500).json({ error: "Ошибка при создании ручного распределения" });
    }
  });

  app.delete("/api/manual-fund-distributions/:id", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const success = await storage.deleteManualFundDistribution(req.params.id, userId);
      if (success) {
        ok(res, { message: "Ручное распределение удалено" });
      } else {
        res.status(404).json({ error: "Распределение не найдено" });
      }
    } catch (error) {
      console.error("Error deleting manual fund distribution:", error);
      res.status(500).json({ error: "Ошибка при удалении ручного распределения" });
    }
  });

  app.get("/api/unallocated-funds", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const unallocatedAmount = await storage.getUnallocatedFunds(userId);
      ok(res, { unallocatedAmount });
    } catch (error) {
      console.error("Error getting unallocated funds:", error);
      res.status(500).json({ error: "Ошибка при получении нераспределенных средств" });
    }
  });

  // Automatically distribute all unallocated funds based on income sources
  app.post("/api/distribute-unallocated-funds", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      await storage.distributeUnallocatedFunds(userId);
      ok(res, { message: "Funds distributed successfully" });
    } catch (error) {
      console.error("Error distributing unallocated funds:", error);
      res.status(500).json({ error: "Ошибка при распределении средств" });
    }
  });

  // Fund balance routes
  app.get("/api/funds-with-balances", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const fundsWithBalances = await storage.getFundsWithBalances(userId);
      ok(res, fundsWithBalances);
    } catch (error) {
      console.error("Error fetching funds with balances:", error);
      serverError(res);
    }
  });

  app.get("/api/funds/:id/balance", requireAuth, async (req: any, res) => {
    try {
      const balance = await storage.getFundBalance(req.params.id);
      ok(res, { balance });
    } catch (error) {
      console.error("Error fetching fund balance:", error);
      serverError(res);
    }
  });

  // Distribution History endpoints
  app.get("/api/distribution-history", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const history = await storage.getDistributionHistoryWithItems(userId);
      ok(res, history);
    } catch (error) {
      console.error("Error fetching distribution history:", error);
      serverError(res);
    }
  });

  app.get("/api/distribution-history/:id", requireAuth, async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = validateUserId(req.user?.claims?.sub);
      
      const history = await storage.getDistributionHistoryById(id, userId);
      if (history) {
        ok(res, history);
      } else {
        notFound(res);
      }
    } catch (error) {
      console.error("Error fetching distribution history:", error);
      serverError(res);
    }
  });

  app.delete("/api/distribution-history/:id", requireAuth, async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = validateUserId(req.user?.claims?.sub);
      
      const deleted = await storage.deleteDistributionHistory(id, userId);
      if (deleted) {
        noContent(res);
      } else {
        notFound(res);
      }
    } catch (error) {
      console.error("Error deleting distribution history:", error);
      serverError(res);
    }
  });

  // Expense Nomenclature routes
  app.get("/api/expense-nomenclature", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const nomenclature = await storage.getExpenseNomenclature(userId);
      ok(res, nomenclature);
    } catch (error) {
      console.error("Error fetching expense nomenclature:", error);
      serverError(res);
    }
  });

  app.get("/api/expense-nomenclature/:id", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const nomenclature = await storage.getExpenseNomenclatureById(req.params.id, userId);
      if (!nomenclature) {
        return notFound(res);
      }
      ok(res, nomenclature);
    } catch (error) {
      console.error("Error fetching expense nomenclature:", error);
      serverError(res);
    }
  });

  app.post("/api/expense-nomenclature", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const validatedData = insertExpenseNomenclatureSchema.parse(req.body);
      const nomenclature = await storage.createExpenseNomenclature(validatedData, userId);
      created(res, nomenclature);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      console.error("Error creating expense nomenclature:", error);
      serverError(res);
    }
  });

  app.put("/api/expense-nomenclature/:id", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const validatedData = insertExpenseNomenclatureSchema.partial().parse(req.body);
      const nomenclature = await storage.updateExpenseNomenclature(req.params.id, validatedData, userId);
      if (!nomenclature) {
        return notFound(res);
      }
      ok(res, nomenclature);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      console.error("Error updating expense nomenclature:", error);
      serverError(res);
    }
  });

  app.delete("/api/expense-nomenclature/:id", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const deleted = await storage.deleteExpenseNomenclature(req.params.id, userId);
      if (!deleted) {
        return notFound(res);
      }
      noContent(res);
    } catch (error) {
      console.error("Error deleting expense nomenclature:", error);
      serverError(res);
    }
  });

  // Expense Categories routes
  app.get("/api/expense-categories", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const categories = await storage.getExpenseCategories(userId);
      ok(res, categories);
    } catch (error) {
      console.error("Error fetching expense categories:", error);
      serverError(res);
    }
  });

  app.get("/api/expense-categories/:id", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const category = await storage.getExpenseCategoryById(req.params.id, userId);
      if (!category) {
        return notFound(res);
      }
      ok(res, category);
    } catch (error) {
      console.error("Error fetching expense category:", error);
      serverError(res);
    }
  });

  app.post("/api/expense-categories", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const validatedData = insertExpenseCategorySchema.parse(req.body);
      const category = await storage.createExpenseCategory(validatedData, userId);
      created(res, category);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      console.error("Error creating expense category:", error);
      serverError(res);
    }
  });

  app.put("/api/expense-categories/:id", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const validatedData = insertExpenseCategorySchema.partial().parse(req.body);
      const category = await storage.updateExpenseCategory(req.params.id, validatedData, userId);
      if (!category) {
        return notFound(res);
      }
      ok(res, category);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      console.error("Error updating expense category:", error);
      serverError(res);
    }
  });

  app.delete("/api/expense-categories/:id", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const deleted = await storage.deleteExpenseCategory(req.params.id, userId);
      if (!deleted) {
        return notFound(res);
      }
      noContent(res);
    } catch (error) {
      console.error("Error deleting expense category:", error);
      serverError(res);
    }
  });

  // Reports API
  app.get("/api/reports/fund-balance/:dateFrom/:dateTo", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const { dateFrom, dateTo } = req.params;
      
      // Get all funds for the user
      const funds = await storage.getFundsWithBalances(userId);
      
      // Get distribution history to calculate period income
      const distributionHistory = await storage.getDistributionHistoryWithItems(userId);
      const costs = await storage.getCosts(userId);
      
      // Filter data by date range
      const startDate = new Date(dateFrom);
      const endDate = new Date(dateTo);
      endDate.setHours(23, 59, 59, 999); // End of day
      
      // Filter distributions within period
      const periodDistributions = distributionHistory.filter((dist: any) => {
        const distDate = new Date(dist.createdAt);
        return distDate >= startDate && distDate <= endDate;
      });
      
      // Filter costs within period
      const periodCosts = costs.filter((cost: any) => {
        const costDate = new Date(cost.date);
        return costDate >= startDate && costDate <= endDate;
      });
      
      // Calculate fund balances and movements
      const fundBalanceReport = funds.map((fund: any) => {
        // Calculate income from distributions in period
        let periodIncome = 0;
        periodDistributions.forEach((dist: any) => {
          if (dist.items && Array.isArray(dist.items)) {
            const fundItems = dist.items.filter((item: any) => item.fundId === fund.id);
            periodIncome += fundItems.reduce((sum: number, item: any) => sum + parseFloat(item.amount), 0);
          }
        });
        
        // Calculate expenses in period
        const fundCosts = periodCosts.filter((cost: any) => cost.fundId === fund.id);
        const periodExpenses = fundCosts.reduce((sum: number, cost: any) => sum + parseFloat(cost.totalAmount), 0);
        
        // Current balance
        const currentBalance = parseFloat(fund.balance);
        
        // Opening balance = current - period income + period expenses
        const openingBalance = Math.max(0, currentBalance - periodIncome + periodExpenses);
        
        return {
          fundName: fund.name,
          openingBalance: openingBalance,
          income: periodIncome,
          expenses: periodExpenses,
          currentBalance: currentBalance
        };
      });
      
      ok(res, fundBalanceReport);
    } catch (error) {
      console.error("Error generating fund balance report:", error);
      serverError(res);
    }
  });

  // Expense Report API
  app.get("/api/reports/expenses/:dateFrom/:dateTo", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const { dateFrom, dateTo } = req.params;
      
      const costs = await storage.getCosts(userId);
      const categories = await storage.getExpenseCategories(userId);
      const nomenclature = await storage.getExpenseNomenclature(userId);
      
      // Filter costs by date range
      const startDate = new Date(dateFrom);
      const endDate = new Date(dateTo);
      endDate.setHours(23, 59, 59, 999);
      
      const periodCosts = costs.filter((cost: any) => {
        const costDate = new Date(cost.date);
        return costDate >= startDate && costDate <= endDate;
      });
      
      // Group by category
      const categoryMap = new Map();
      
      categories.forEach((category: any) => {
        categoryMap.set(category.id, {
          categoryName: category.name,
          expenses: []
        });
      });
      
      // Add costs to categories
      periodCosts.forEach((cost: any) => {
        const nomenclatureItem = nomenclature.find((n: any) => n.id === cost.expenseNomenclatureId);
        const nomenclatureName = nomenclatureItem ? nomenclatureItem.name : "Без номенклатуры";
        
        if (categoryMap.has(cost.expenseCategoryId)) {
          categoryMap.get(cost.expenseCategoryId).expenses.push({
            name: nomenclatureName,
            amount: parseFloat(cost.totalAmount)
          });
        }
      });
      
      // Convert to array and filter out empty categories
      const reportData = Array.from(categoryMap.values()).filter((category: any) => category.expenses.length > 0);
      
      ok(res, reportData);
    } catch (error) {
      console.error("Error generating expense report:", error);
      serverError(res);
    }
  });

  // Sponsor Report API
  app.get("/api/reports/sponsors/:dateFrom/:dateTo", requireAuth, async (req: any, res) => {
    try {
      const userId = validateUserId(req.user?.claims?.sub);
      const { dateFrom, dateTo } = req.params;
      
      const receipts = await storage.getReceipts(userId);
      const sponsors = await storage.getSponsors(userId);
      
      // Filter receipts by date range
      const startDate = new Date(dateFrom);
      const endDate = new Date(dateTo);
      endDate.setHours(23, 59, 59, 999);
      
      const periodReceipts = receipts.filter((receipt: any) => {
        const receiptDate = new Date(receipt.date);
        return receiptDate >= startDate && receiptDate <= endDate;
      });
      
      // Get receipt items for these receipts
      const sponsorMap = new Map();
      
      // Initialize sponsors map
      sponsors.forEach((sponsor: any) => {
        sponsorMap.set(sponsor.id, {
          sponsorName: sponsor.name,
          totalAmount: 0
        });
      });
      
      // Process receipt items to get sponsor totals
      for (const receipt of periodReceipts) {
        const receiptItems = await storage.getReceiptItems(receipt.id);
        
        receiptItems.forEach((item: any) => {
          if (sponsorMap.has(item.sponsorId)) {
            const sponsorData = sponsorMap.get(item.sponsorId);
            sponsorData.totalAmount += parseFloat(item.amount);
          }
        });
      }
      
      // Filter out sponsors with no donations and convert to array
      const reportData = Array.from(sponsorMap.values())
        .filter((sponsor: any) => sponsor.totalAmount > 0);
      
      ok(res, reportData);
    } catch (error) {
      console.error("Error generating sponsor report:", error);
      serverError(res);
    }
  });

  const httpServer = createServer(app);
  return httpServer;
}
